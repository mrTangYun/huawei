<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>imageDraw</title>
  	<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
  	<script src="http://hammerjs.github.io/dist/hammer.js"></script>
	<script src="./js/jquery.js"></script>
	<link rel="stylesheet" href="./css/css.css" />
</head>
<body>
	<div class="canvasOuter">
		<canvas id="canvas" style="transform: rotate(5deg); ">
			
		</canvas>
		<div id="btn-djsczp">
			<img src="./images/btn-djsczp.png" width="100%" alt="">
		</div>
	</div>
	<div id="tips"></div>
	<div id="hide">
	<input id="inputFile" type="file" onchange="previewFile()"><br>
	<img id="previewImg" src="" height="200" alt="Image preview...">
	</div>
	<br/>
	<a href="./">微信版本</a>
	<div id="toImgUrl">生成图片</div>
	<img id="newImg" src="">
</body>
<script>
var img = new Image();
function previewFile() {
  var preview = document.getElementById("previewImg");
  var file    = document.querySelector('input[type=file]').files[0];
  var reader  = new FileReader();

  reader.addEventListener("load", function () {
    //preview.src = reader.result;
    img.src = reader.result;
  }, false);

  if (file &&  /\.(jpe?g|png|gif)$/i.test(file.name) ) {
  	//console.log(file);
  	//$("#tips").text(/\.(jpe?g|png|gif)$/i.test(file.name));
    reader.readAsDataURL(file);
  }
  else{
  	$("#tips").text("请选择图片");
  	$("#btn-djsczp").show();
  	setTimeout(function(){
  		$("#btn-djsczp").removeClass('hide');
  	},1);
  }
}
	document.body.addEventListener('touchmove', function (event) {
	    event.preventDefault();
	}, false);

		
	jQuery(document).ready(function($) {
      

		var canvas = document.getElementById("canvas");
		var ctx = canvas.getContext("2d");
		canvas.width = document.body.clientWidth;
		canvas.height = 300;

		var WIDTH = canvas.width;
		var HEIGHT = canvas.height;

		var liveScale = 1;
    	var currentRotation = 0;
		var hammertime = new Hammer(canvas);
		hammertime.get('rotate').set({ enable: true });
		hammertime.get('pinch').set({ enable: true });
		hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL });

		$("#toImgUrl").click(function(event) {
			/* Act on the event */
			//console.log(canvas);
			console.log(canvas.toDataURL("image/png"));
			$("#newImg").attr("src",canvas.toDataURL("image/png"));
		});

		var outerImg = new Image();
		//outerImg.src = "./images/1.png";
        
        	outerImg.src = "./images/1.png";
			outerImg.onload = function(){
				ctx.drawImage(outerImg,0,0,WIDTH,HEIGHT);
				$("#btn-djsczp").on('click', function(event) {
					$("#btn-djsczp").addClass('hide');
					$("#inputFile").click();
					setTimeout(function(){
						$("#btn-djsczp").hide();
					},1000);
				});
			}


			//return false;
			//img.src = "./images/360205246780165223b.jpg"
			
	        img.onload = function(e){
				var imgWidth = img.width,
					imgHeight = img.height,
					rC = WIDTH / HEIGHT,
					rI = imgWidth / imgHeight,
					w,
					y,
					cImg = {
						r : 0,	//旋转
						x : 0,
						y : 0,
						w : WIDTH,
						h : HEIGHT,
						f : 0, 	//0长宽相等，1比c高，2比c宽,
						c : 1,	//缩放
						rx : .5,
						ry : .5
					};
				if (rC > rI){
					//如果图片的长宽比比canvas的小
					h =  WIDTH / rI;
					cImg.y = (HEIGHT - h)/2 - HEIGHT/2 ;
					cImg.x = WIDTH / -2;
					cImg.h = h;
					cImg.f = 1;
				}
				else if (rC < rI){
					//如果图片的长宽比比canvas的大
					w =  HEIGHT * rI;
					cImg.x = (WIDTH-w)/2 - WIDTH/2;
					cImg.y = HEIGHT / -2;
					cImg.w = w;
					cImg.f = 2;
				}
				
				draw(ctx,cImg);

				function update(cImg,mouse,mouse_last,touches,touches_last){
					
					if (touches.length === 1){
						// 单个手指
						if (!cImg.f){
							return false;
						}
						else if(cImg.f == 1){
							var _y = cImg.y + (mouse.y - mouse_last.y);
							if (_y >= 0){
								cImg.y = 0;
							}
							else if (_y*-1 + HEIGHT > cImg.h){
								cImg.y = HEIGHT - cImg.h;
							}
							else{
								cImg.y = _y;
							}
						}
						else{
							var _x = cImg.x + (mouse.x - mouse_last.x);
							if (_x >= 0){
								cImg.x = 0;
							}
							else if (_x*-1 + WIDTH > cImg.w){
								cImg.x = WIDTH - cImg.w;
							}
							else{
								cImg.x = _x;
							}
						}
					}
					
				}
				function draw(ctx,cImg){
					ctx.clearRect(0, 0, WIDTH, HEIGHT);
					ctx.save();
					ctx.translate(WIDTH/2,HEIGHT/2);
					ctx.rotate(cImg.r *Math.PI /180);
					//console.log(cImg.r);
					ctx.scale(cImg.c,cImg.c);
					ctx.drawImage(img,cImg.x,cImg.y,cImg.w,cImg.h);
					ctx.restore();
					ctx.drawImage(outerImg,0,0,WIDTH,HEIGHT);

				}

				var isMove = false,
					mouse_last = {
						x : 0,
						y : 0
					},
					touches = [];
				var lastRotate = 0,
					lastScale = 0,
					lastPan = {x :0,y:0};
				hammertime.on('rotatestart', function(ev) {
					//console.log('rotatestart' ,ev);
					lastRotate = ev.rotation;
					lastPan = ev.center;
				});
				hammertime.on('rotatemove', function(ev) {
					//console.log('rotatemove' ,ev);
					var r = lastRotate - ev.rotation;
					cImg.r -= r;
					var radians = cImg.r * Math.PI / 180;
					cImg.x = cImg.x +  (ev.center.x - lastPan.x) * Math.cos(radians) + (ev.center.y - lastPan.y) * Math.sin(radians);
					cImg.y = cImg.y +  (ev.center.y - lastPan.y) * Math.cos(radians) - (ev.center.x - lastPan.x) * Math.sin(radians);
					draw(ctx,cImg);
					lastRotate = ev.rotation;
					lastPan = ev.center;
				});
				hammertime.on( "rotateend", function( ev ) {
					//console.log("rotateend" ,ev);
					lastRotate = ev.rotation;
					lastPan = ev.center;
	    		});

				hammertime.on('pinchstart', function(ev) {
					//console.log('pinchstart' ,ev.scale);
					lastScale = ev.scale;
				});
				hammertime.on('pinchmove', function(ev) {
					//console.log('pinchmove' ,ev.scale);
					cImg.c -= (lastScale-ev.scale);
					lastScale = ev.scale;
				});
				hammertime.on( "pinchend", function( ev ) {
					//console.log("pinchend" ,ev.scale);
					lastScale = ev.scale;
	    		});


	    		hammertime.on("panstart", function( ev ) {
					lastPan = ev.center;
	    		});
	    		hammertime.on("panend", function( ev ) {
					lastPan = ev.center;
	    		});
	    		hammertime.on("panmove", function( ev ) {
					var radians = cImg.r * Math.PI / 180;
					cImg.x = cImg.x +  (ev.center.x - lastPan.x) * Math.cos(radians) + (ev.center.y - lastPan.y) * Math.sin(radians);
					cImg.y = cImg.y +  (ev.center.y - lastPan.y) * Math.cos(radians) - (ev.center.x - lastPan.x) * Math.sin(radians);
					
					draw(ctx,cImg);
					lastPan = ev.center;
	    		});
			}



		
        
	});
</script>
</html>